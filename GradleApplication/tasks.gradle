//当任务图创建的时候这个回调会自动执行，你知道这个逻辑会在任何任务之前执行,所以你可以自定义做一些操作
gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
//    使用Groovy语法调用getAllTasks方法获取所有的task，通过findAll方法把所有以lint开头的任务的enabled属性设置为false，这样这些任务就不会执行
//    taskGraph.allTasks.findAll { it.name ==~ /lint.*/ }*.enabled = false

//    > gradle distribution
//    运行任务图中没有release-task，输出 We build the zip with version=1.0-SNAPSHOT
//    > release
//    运行任务图中有release-task，输出 We build the zip with version=1.0
//    if (taskGraph.hasTask(release)) {
//        version = '1.0'
//    } else {
//        version = '1.0-SNAPSHOT'
//    }
    tasks.updateAAR.execute()
    println "updateAAR.execute()--------------------------"
}
//监听了task的添加流程，在'preReleaseBuild'和'preDebugBuild'的execute阶段添加了代码逻辑。
//在'preReleaseBuild'和'preDebugBuild'执行完后，执行lib模块中的onRelease或者onDebug方法。
tasks.whenTaskAdded { task ->
    if (task.name == 'preReleaseBuild') {
        // release build
        task.doLast {
            def taskProject = rootProject.subprojects.findAll {it.name == "lib"}
            taskProject[0].onRelease()
        }
    } else if (task.name == 'preDebugBuild') {
        // debug build
        task.doLast {
            def taskProject = rootProject.subprojects.findAll {it.name == "lib"}
            taskProject[0].onDebug()
        }
    }
}
task updateAAR << {
    eachModuleAAR()
}

String SDK_DIR = System.getenv("ANDROID_SDK_HOME")
if (SDK_DIR == null) {
    Properties props = new Properties()
    props.load(new FileInputStream(project.rootProject.file("local.properties")))
    SDK_DIR = props.get('sdk.dir');
}

/**
 * 复制APK
 */
def copyApk = {
    srcFile, name ->
        def inFile = file(srcFile)
        def outFile = new File("${gradle.outApk}/${name}")//输出的文件
        outFile.withOutputStream { os -> inFile.withInputStream { ins -> os << ins } }

}


/**
 * super cleaner cn版本
 */
def compressCleanCn = {
    name ->
        //减去.apk
        def path = name.substring(0, name.length() - 4)
        def guardJarFile = file('./AndResGuard/AndResGuard-cli-1.1.10.jar')
        def guardConfigFile = file('./AndResGuard/config_cn.xml')
        def originApkFile = file("./outapk/archives/${name}")
        def outputDir = file("./build/${path}")
        // 开始执行压缩命令
        def proc = """java -jar ${guardJarFile} ${originApkFile} -config ${guardConfigFile}
                    -out ${outputDir} -zipalign  $SDK_DIR/build-tools/23.0.2/zipalign""".execute()
        proc.waitFor()
        if (proc.exitValue() == 0) {
            println "cn压缩开始:\t\n${proc.in.text}"
            def preApk = Math.round(originApkFile.length() / 1024 * 100) / 100
            println "cn压缩前：${preApk}K"
            outputDir.eachFile {
                if (it.name.contains("7zip_aligned")) {
                    def afterApk = Math.round(it.length() / 1024 * 100) / 100
                    println "cn压缩后：${afterApk}K"
                    copyApk.call(it.getAbsolutePath(), name)
                }
            }
        } else {
            println "错误日志：\n${proc.err.text}"
        }
}

/**
 * gradlew  compressApp
 * 对包进行微信资源压缩
 */
task compressApp << {
    //清理build目录，可不加
//    delete rootProject.buildDir
    //遍历apk文件
    new File("./outapk/archives").eachFile {
        if (it.name.endsWith(".apk")) {
            println "**************${it.name}******************"


            if (it.name.contains("buildVersion")
                    || it.name.contains("dev")) {
                compressSpacePlus.call(it.name)
            } else if (it.name.contains("xu")) {
                compressXu.call(it.name)
            } else if (it.name.contains("cn")) {
                compressCleanCn.call(it.name)
            } else if (it.name.contains("hawkGP")) {
                compress.call(it.name)
            } else if (it.name.contains("usercare") || it.name.contains("spreadapps")
                    || it.name.contains("fota") || it.name.contains("phoneGuardGP") || it.name.contains("silentapps")) {
                compressPhoneGuard.call(it.name)
            } else if (it.name.contains("tracker") || it.name.contains("miePreload")) {
                compressTctPhoneGuard.call(it.name)
            } else if (it.name.contains("cleanerAndroid")) {
                compressCleanAndroid.call(it.name)
            } else {
                compress.call(it.name)
            }
            println "********${it.name}压缩完成***********"
        }
    }
    println "压缩完成"
}
//打包命名
def eachModuleAAR(){
    def libPath= getRootProject().projectDir.getAbsolutePath()+"/libs/";
    for (Project project : getRootProject().getAllprojects()) {
        println  "eachModuleAAR-------------"+project.name.toString()
        def projectModuleAARPath=project.buildDir.absolutePath+"/outputs/aar/";
        def dir = new File(projectModuleAARPath)
        if (!dir.exists()) continue
        dir.eachFile { File file ->
            copy{
                from file.absolutePath
                into libPath
            }
            println  project.name + ' Update SUCCESS!'
        }
    }
}

/**
 * 获取apk
 */
task archiveOutApks(type: Copy) {
    from('cleaner/build/outputs/apk')
    exclude '*unaligned*'
    into('./outapk/archives')
}

task myTask {
    println "config myTask"
}
myTask.doLast {
    println "after execute myTask"
}

myTask.doFirst {
    println "before execute myTask"
}

task first << { println "first" }
task second << { println "second" }

//声明多个依赖
task printVersion(dependsOn: [second, first]) << {
    logger.quiet "Version: $version"
}

task third << { println "third" }
//通过任务名称来声明依赖
third.dependsOn('printVersion')

task buildReleaseApk(dependsOn: [ 'assembleRelease']) {
    doLast {
        // 基于 versionCode 创建 apk 名称。
        applicationVariants.all { variant ->
//            if (variant.buildType.name.equals('release')) {
//                variant.outputs.each { output ->
//                    def appName = 'pm_'
//                    def oldFile = output.outputFile
//                    def releaseApkName
//                    //由于还是测试版本，所以用"0."开头，每次发布自增0.001，如有其他需求，可自行修改计算方法及前后缀即可
//                    releaseApkName = appName + "0." + verCode + '.APK'
//                    output.outputFile = new File(oldFile.parent, releaseApkName)
//                }
//            }
        }
        // 确保不存在相同名字的文件。

        // 判断是否已经完成 build，然后把文件复制到目标文件夹。

    }
}


class MyTask extends DefaultTask {
    @TaskAction
    void action(){
        println "action1+++++"
    }
}
//创建 hello3 task
task hello3 (type: MyTask){
    doLast{
        println "action2+++++"
    }
}
//gradlew hello3   outputs: action1+++++ action2+++++
task clean(type: Delete) {
    println "task clean----------------------"
    delete rootProject.buildDir
}